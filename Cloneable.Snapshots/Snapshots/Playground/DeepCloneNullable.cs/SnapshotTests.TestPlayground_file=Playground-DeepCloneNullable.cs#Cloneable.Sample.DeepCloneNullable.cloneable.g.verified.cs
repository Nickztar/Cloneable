//HintName: Cloneable.Sample.DeepCloneNullable.cloneable.g.cs
// <auto-generated/>
#nullable enable
using System;
using System.Linq;

namespace Cloneable.Sample;
public partial class DeepCloneNullable
{
    /// <summary>
    /// Creates a copy of DeepCloneNullable with NO circular reference checking. This method should be used if performance matters.
    /// <exception cref="StackOverflowException">Will occur on any object that has circular references in the hierarchy.</exception>
    /// </summary>
    public global::Cloneable.Sample.DeepCloneNullable Clone()
    {
        return new global::Cloneable.Sample.DeepCloneNullable
        {
            A = this.A,
            Simple = this.Simple?.Clone(),
        };
    }
    /// <summary>
    /// Creates a copy of DeepCloneNullable with circular reference checking. If a circular reference was detected, only a reference of the leaf object is passed instead of cloning it.
    /// </summary>
    /// <param name="referenceChain">Should only be provided if specific objects should not be cloned but passed by reference instead.</param>
    public global::Cloneable.Sample.DeepCloneNullable CloneSafe(global::System.Collections.Generic.Stack<object>? referenceChain = null)
    {
        if (referenceChain?.Contains(this) == true) return this;
        referenceChain ??= new global::System.Collections.Generic.Stack<object>();
        referenceChain.Push(this);
        var clone = new global::Cloneable.Sample.DeepCloneNullable
        {
            A = this.A,
            Simple = this.Simple?.CloneSafe(referenceChain),
        };
        referenceChain.Pop();
        return clone;
    }
}
