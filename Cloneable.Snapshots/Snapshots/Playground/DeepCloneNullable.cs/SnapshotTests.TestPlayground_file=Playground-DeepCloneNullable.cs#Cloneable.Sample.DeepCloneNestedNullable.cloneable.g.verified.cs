//HintName: Cloneable.Sample.DeepCloneNestedNullable.cloneable.g.cs
// <auto-generated/>
using System;
using System.Linq;

namespace Cloneable.Sample;
public partial class DeepCloneNestedNullable
{
    /// <summary>
    /// Creates a copy of DeepCloneNestedNullable with NO circular reference checking. This method should be used if performance matters.
    /// <exception cref="StackOverflowException">Will occur on any object that has circular references in the hierarchy.</exception>
    /// </summary>
    public global::Cloneable.Sample.DeepCloneNestedNullable Clone()
    {
        return new global::Cloneable.Sample.DeepCloneNestedNullable
        {
            A = this.A,
            Simple = Simple.Select(Simplex => Simplex?.Clone()).ToArray(),
        };
    }
    /// <summary>
    /// Creates a copy of DeepCloneNestedNullable with circular reference checking. If a circular reference was detected, only a reference of the leaf object is passed instead of cloning it.
    /// </summary>
    /// <param name="referenceChain">Should only be provided if specific objects should not be cloned but passed by reference instead.</param>
    public global::Cloneable.Sample.DeepCloneNestedNullable CloneSafe(global::System.Collections.Generic.Stack<object> referenceChain = null)
    {
        if (referenceChain?.Contains(this) == true) return this;
        referenceChain ??= new global::System.Collections.Generic.Stack<object>();
        referenceChain.Push(this);
        var clone = new global::Cloneable.Sample.DeepCloneNestedNullable
        {
            A = this.A,
            Simple = Simple.Select(Simplex => Simplex?.CloneSafe(referenceChain)).ToArray(),
        };
        referenceChain.Pop();
        return clone;
    }
}
