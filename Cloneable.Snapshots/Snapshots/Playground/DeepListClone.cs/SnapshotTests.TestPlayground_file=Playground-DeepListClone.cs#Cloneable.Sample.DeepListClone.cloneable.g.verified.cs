//HintName: Cloneable.Sample.DeepListClone.cloneable.g.cs
// <auto-generated/>
#nullable enable
using System;
using System.Linq;

namespace Cloneable.Sample;
public partial class DeepListClone
{
    /// <summary>
    /// Creates a copy of DeepListClone with NO circular reference checking. This method should be used if performance matters.
    /// <exception cref="StackOverflowException">Will occur on any object that has circular references in the hierarchy.</exception>
    /// </summary>
    public global::Cloneable.Sample.DeepListClone Clone()
    {
        return new global::Cloneable.Sample.DeepListClone
        {
            A = this.A,
            B = new global::System.Collections.Generic.List<global::Cloneable.Sample.SimpleClone>(B.Select(Bx => Bx.Clone())),
        };
    }
    /// <summary>
    /// Creates a copy of DeepListClone with circular reference checking. If a circular reference was detected, only a reference of the leaf object is passed instead of cloning it.
    /// </summary>
    /// <param name="referenceChain">Should only be provided if specific objects should not be cloned but passed by reference instead.</param>
    public global::Cloneable.Sample.DeepListClone CloneSafe(global::System.Collections.Generic.Stack<object>? referenceChain = null)
    {
        if (referenceChain?.Contains(this) == true) return this;
        referenceChain ??= new global::System.Collections.Generic.Stack<object>();
        referenceChain.Push(this);
        var clone = new global::Cloneable.Sample.DeepListClone
        {
            A = this.A,
            B = new global::System.Collections.Generic.List<global::Cloneable.Sample.SimpleClone>(B.Select(Bx => Bx.CloneSafe(referenceChain))),
        };
        referenceChain.Pop();
        return clone;
    }
}
